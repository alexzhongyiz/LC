
1. StrangeSorting:


#mapping is like [3,5,4,6,2,7,9,8,0,1]
#nums is like['990', '332', '32']
import collections
def sortingArray(mapping, nums) -> list:
    if not nums:
        return []
    dic = collections.defaultdict(list)
    for i in range(len(nums)):
        num = nums[i]
        actual_digits = [str(mapping.index(int(num[j]))) for j in range(len(num)) ]
        actual_num = int("".join(actual_digits))
        dic[actual_num].append(i)
    #print(dic)
    actual_nums = list(dic.keys())
    actual_nums.sort()
    #print(actual_nums)
    res = []
    for actual_num in actual_nums:
        for index  in dic[actual_num]:
            res.append(nums[index])
    return res
    
    
 
 
2. Rotate the string:
#originalString is like ['a', 'c', 'e','a', 'h','j','z','l'] or 'abcdefg'
#direction = [0,1,0,0,1]# 0 denote left
#amount = [1,3,5,14,6]
def rotateTheString(originalString, direction, amount):
    if len(originalString) in {0,1}:
        return originalString
    q = len(direction)
    total_amount = 0
    for i in range(q):
        total_amount += amount[i]* (2*direction[i] - 1)
    #print(total_amount, len(originalString))
    
    amount_to_right = total_amount % len(originalString)
    return originalString[len(originalString) - amount_to_right:] + originalString[: len(originalString) - amount_to_right]
    
    
3. Share Purchases:

#list the number of substring that contains the most three major companies(represented by most 3 common letters)
#eg: s = 'ABCZBCA', then {ABC, ABCZ, ...ABCZBCA, BCZBCA, CZBCA, ZBCA, BCA} are the possible substrings 

def analyzeInvestments(s):
    """
    import collections
    count = collections.Counter(s)
    BigThree = [k for k, v in count.most_common(3)]
    
    #above three lines is when the three letters are not necessarily ABC
    """
    BigThree = ['A', 'B', 'C']
    print(BigThree)
    ans = 0
    visited = {}
    for i in range(0, len(s) - 2):
        for letter in BigThree:
            visited[letter] = False
        if s[i] in BigThree:
            visited[s[i]] = True
            
        for j in range(i + 1, len(s)):
            if s[j] in BigThree and visited[s[j]] == False:
                visited[s[j]] = True
                if all(visited.values()):
                    ans += len(s) - j 
                    break
    return ans
          
4.Grid Game:

def gridGame(grid, k, rules):
    if not grid or not grid[0]:
        return grid
    
    def count_alive_neighbor(grid,i,j):
        cur = 0
        for v in [-1,0,1]:
            if i + v <0 or i+ v >= len(grid):
                continue
            for h in [-1,0,1]:
                 if 0<= j+ h< len(grid[0]):
                    cur = cur + 1 if grid[i + v][j + h] else cur
        cur = cur - 1 if grid[i][j] else cur
        return cur
                
    
    n,m = len(grid), len(grid[0])
    for turn in range(k):
        count = [[0]*m for _ in range(n)]
        for i in range(n):
            for j in range(m):
                count[i][j] = count_alive_neighbor(grid,i,j)
        for i in range(n):
            for j in range(m):
                grid[i][j] = [0,1][rules[count[i][j]] == 'alive']
       # print(grid)
    return grid
    
