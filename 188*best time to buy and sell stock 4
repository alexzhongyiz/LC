first attempt, O(n^2), TLE
def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0
        
        dp = [[0]* (k+1) for _ in range(len(prices))]
        
        for i in range(1, len(prices)):
            for l in range(1, k + 1):
                dp[i][l] =max(max(dp[j][l -1] + max(prices[i] - prices[j],0) for j in range(i)), dp[i-1][l])
                
        return dp[-1][k]
        
 Second Attemp: O(n) and O(N * k) space, Runtime Error when k>>len(prices):
 state machine.
 
 
 def maxProfit(self, k: int, prices: List[int]) -> int:
        if len(prices) <=1:
            return 0
            
        if k >= len(prices)//2: #this step is crucial when k is larger than needed.
            return sum(max(prices[i] - prices[i -1], 0) for i in range(1, len(prices)))
        
        cash = [[0]* (k+ 1) for _ in range(len(prices))]
        hold = [[0]*(k + 1) for _ in range(len(prices))]
        
        cash[1] = [0] + [max(prices[1] - prices[0], 0)]*k
        hold[0] = [-prices[0]] * (k + 1)
        
        for i in range(1, len(prices)):
            hold[i][0] = max(hold[i -1][0], -prices[i])
            for l in range(1, k + 1):
                hold[i][l] = max(hold[i -1][l], cash[i -1] [l] - prices[i])
                cash[i][l] = max(cash[i -1][l], hold[i -1][l -1] + prices[i])
        #print(cash)
        #print(hold)
        return cash[-1][k]
